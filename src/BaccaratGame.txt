pragma solidity ^0.8.0;
  import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
  import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

  contract BaccaratGame is VRFConsumerBaseV2 {
      VRFCoordinatorV2Interface COORDINATOR;

      uint64 subscriptionId;
      address vrfCoordinator = 0x9Ddfa5485180a9CaF06503F26B4aD6A2527F5B5a; // Sepolia
      bytes32 keyHash = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d36;
      uint32 callbackGasLimit = 100000;
      uint16 requestConfirmations = 3;
      uint32 numWords = 10;

      struct Bet {
          address player;
          string betType;
          uint256 amount;
      }

      mapping(uint256 => Bet[]) public gameBets;
      mapping(uint256 => uint256[]) public gameRandoms;
      uint256 public currentGameId;
      address public owner;

      event BetPlaced(address indexed player, string betType, uint256 amount);
      event GameResult(string winner, uint256 playerScore, uint256 bankerScore);

      constructor(uint64 _subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
          COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
          subscriptionId = _subscriptionId;
          owner = msg.sender;
      }

      function placeBet(string memory betType) public payable {
          require(msg.value >= 0.01 ether, "Minimum bet is 0.01 ETH");
          require(keccak256(bytes(betType)) == keccak256(bytes("player")) ||
                  keccak256(bytes(betType)) == keccak256(bytes("banker")) ||
                  keccak256(bytes(betType)) == keccak256(bytes("tie")), "Invalid bet type");

          gameBets[currentGameId].push(Bet(msg.sender, betType, msg.value));
          emit BetPlaced(msg.sender, betType, msg.value);
      }

      function dealCards() public {
          require(gameBets[currentGameId].length > 0, "No bets placed");
          COORDINATOR.requestRandomWords(
              keyHash,
              subscriptionId,
              requestConfirmations,
              callbackGasLimit,
              numWords
          );
      }

      function fulfillRandomWords(uint256, uint256[] memory randomWords) internal override {
          gameRandoms[currentGameId] = randomWords;
          calculateResult();
      }

      function calculateResult() internal {
          uint256 playerScore = gameRandoms[currentGameId][0] % 10;
          uint256 bankerScore = gameRandoms[currentGameId][1] % 10;
          string memory winner = playerScore > bankerScore ? "player" : bankerScore > playerScore ? "banker" : "tie";

          emit GameResult(winner, playerScore, bankerScore);

          for (uint i = 0; i < gameBets[currentGameId].length; i++) {
              Bet memory bet = gameBets[currentGameId][i];
              if (keccak256(bytes(bet.betType)) == keccak256(bytes(winner))) {
                  uint256 payout = winner == "tie" ? bet.amount * 8 : bet.amount * 2;
                  payable(bet.player).transfer(payout);
              }
          }

          currentGameId++;
      }
  }